'use strict';

/*
 * N.B.	in an ideal world this would all be getting generated by a CMS
 * 		or similar (which is why it outputs strings), or be static html/svg
 */

// define the content for the list & ring items
const	content	= [
					{
						text	: 'Getting started',
						icon	: 'one',
						image	: 'https://source.unsplash.com/PGnqT0rXWLs/480x480'
					},
					{
						text	: 'Focusing on the future',
						icon	: 'two',
						image	: 'https://source.unsplash.com/nF8xhLMmg0c/480x480'
					},
					{
						text	: 'Thinking about retirement',
						icon	: 'three',
						image	: 'https://source.unsplash.com/NoRsyXmHGpI/480x480'
					},
					{
						text	: 'Enjoying your retirement',
						icon	: 'four',
						image	: 'https://source.unsplash.com/6bKpHAun4d8/480x480'
					},
					{
						text	: 'Creating a legacy',
						icon	: 'five',
						image	: 'https://source.unsplash.com/zdSoe8za6Hs/480x480'
					}
				];



// quick and dirty outputting code:
const	ctrlsstr	= getCtrlsHTML( content );
const	svgstr		= getRingXML( content );

document.getElementById( 'ringctrls' ).innerHTML	= ctrlsstr;
document.getElementById( 'ring' ).innerHTML			= svgstr;



function getCtrlsHTML( items = [] ) {
	
	const	 strbuffer	= [];
	
	for ( let i = 0, l = items.length; i < l; i++ ) {
		
		const	item	= items[ i ];
		
		strbuffer.push( '<li>' );
		
		strbuffer.push( `<button data-img="${item.image}">${item.text}</button>` );
		
		strbuffer.push( '</li>' );
		
	}
	
	return	strbuffer.join('');
	
}


function getRingXML( items = [], radius = 240, cx = 300, cy = 300 ) {
	
	const	count		= items.length;
	
	const	strbuffer	= [],	// overall string to return
			arrbuffer	= [],	// arrows layer
			icnbuffer	= [],	// icons layer
			mskbuffer	= [],	// clip mask for image layer
			imgbuffer	= [];	// icon specific images
	
	
	// build up strings dependant on items
	const	step	= ( 2 * Math.PI / count );	// angle between items
	
	let	current	= Math.PI / 2 + Math.PI / 5; // initial angle (TODO pass in or calculate)
	
	for ( let i = 0; i < count; i++ ) {
		
		const	buffers	= getSectionXML(
							items[ i ],
							radius,
							[ cx, cy ],
							step,
							current
						);
		
		arrbuffer.push( buffers.arrow );
		icnbuffer.push( buffers.icon );
		mskbuffer.push( buffers.mask );
		imgbuffer.push( buffers.image );
		
		current	+= step;
		
	}
	
	
	// output mask for image
	// N.B. this isn' quite "optimal" but it'll make the code easier
	// to understand
	strbuffer.push( `<defs>` );
	strbuffer.push( `<mask id="imgclipper">` );
	// shape is a circle...
	strbuffer.push( `<circle cx="${cx}" cy="${cy}" r="${ radius * 0.9 }" fill="white" />` );
	// with cutouts for each item
	strbuffer.push( mskbuffer.join('') );
	strbuffer.push( `</mask>` );
	strbuffer.push( `</defs>` );
	
	// wrap content in a <g> for neatness
	strbuffer.push( '<g class="ring">' );
	
	// output image
	strbuffer.push( `<image class="selected" mask="url(#imgclipper)" x="${cx - radius}" y="${cy - radius}" height="${radius * 2}" width="${radius * 2}" href="https://source.unsplash.com/PMxT0XtQ--A/${radius * 2}x${radius * 2}" />` );
	
	// output the item specific images (wrapped in a <g> for nth-child() selection)
	strbuffer.push( '<g class="ringimages">' );
	strbuffer.push( imgbuffer.join('') );
	strbuffer.push( '</g>' );
	
	
	// output the arrows & icons
	
	// output the arrows & icons, wrapping in <g>s so we can use
	// nth-child() selectors in the interaction script
	strbuffer.push( '<g>' );
	strbuffer.push( arrbuffer.join('') );
	strbuffer.push( '</g>' );
	
	strbuffer.push( '<g>' );
	strbuffer.push( icnbuffer.join('') );
	strbuffer.push( '</g>' );
	
	// close outer wrap
	strbuffer.push( '</g>' );
	
	
	return	strbuffer.join('');
	
};

function getSectionXML( data, radius, [ cx, cy ], theta, initial ) {
	
	const	size	= radius / 10;
	
	const	arrbuffer	= [],
			icnbuffer	= [],
			mskbuffer	= [],
			imgbuffer	= [];
				
	// arrow
	
	// start point
	const	sangle	= initial - theta + Math.PI / 30,	// space for disk
			
			sx	= cx + ( radius * Math.cos( sangle ) ),
			sy	= cy + ( radius * Math.sin( sangle ) );
	
	// end point
	const	eangle	= initial - theta + ( theta * 0.80 ),
			
			ex	= cx + ( radius * Math.cos( eangle ) ),
			ey	= cy + ( radius * Math.sin( eangle ) );
	
	// wrap for styling / animation
	arrbuffer.push( '<g class="ringitem--arrow">' );
	
	arrbuffer.push( `<path d="M${sx} ${sy}A${radius} ${radius} 0 0 1 ${ex} ${ey}" />` );
	
	// arrowhead (two sides makes it easier to draw & animate)
	arrbuffer.push( `<path d="m${ex} ${ey} ${radius / 20} -${radius / 20}" style="transform:rotate(${eangle}rad);transform-origin:${ex}px ${ey}px" />` );
	arrbuffer.push( `<path d="m${ex} ${ey} -${radius / 20} -${radius / 20}" style="transform:rotate(${eangle}rad);transform-origin:${ex}px ${ey}px" />` );
	
	// duplicate to facilitate "drawing line" animation
	arrbuffer.push( `<path class="animable" pathLength="100" d="M${sx} ${sy}A${radius} ${radius} 0 0 1 ${ex} ${ey}" />` );
	arrbuffer.push( `<path class="animable" pathLength="100" d="m${ex} ${ey} ${radius / 20} -${radius / 20}" style="transform:rotate(${eangle}rad);transform-origin:${ex}px ${ey}px" />` );
	arrbuffer.push( `<path class="animable" pathLength="100" d="m${ex} ${ey} -${radius / 20} -${radius / 20}" style="transform:rotate(${eangle}rad);transform-origin:${ex}px ${ey}px" />` );
	
	// close wrap
	arrbuffer.push( '</g>' );
	
	
	// actual item
	
	// item position
	const	px	= cx + ( radius * Math.cos( initial ) ),
			py	= cy + ( radius * Math.sin( initial ) );
	
	// wrap for styling / animation
	// N.B.	outputing the transform origin in the style attribute because
	//		SVGs are weird about handling transforms
	icnbuffer.push( `<g class="ringitem--icon" style="--to:${px}px ${py}px">` );
	
	// disc
	icnbuffer.push( `<circle cx="${px}" cy="${py}" r="${size}" />` );
	
	// icon
	icnbuffer.push( `<use height="${size}" width="${size}" x="${px - size / 2}" y="${py - size / 2}" xlink:href="#${data.icon}" />` );
	
	// close wrap
	icnbuffer.push( '</g>' );
	
	
	// disc for clipping mask
	mskbuffer.push( `<circle cx="${px}" cy="${py}" r="${radius / 5}" />` );
	
	// main image associated with this icon
	imgbuffer.push( `<image mask="url(#imgclipper)" x="${cx - radius}" y="${cy - radius}" height="${radius * 2}" width="${radius * 2}" href="${data.image}" />` );
	
	
	return	{
				arrow	: arrbuffer.join(''),
				icon	: icnbuffer.join(''),
				mask	: mskbuffer.join(''),
				image	: imgbuffer.join('')
			};
	
}

